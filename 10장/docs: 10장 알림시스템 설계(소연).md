# # 10장. 알림 시스템 설계

### 1.  문제 상황과 요구 사항
SNS, 메신저, 전자상거래 플랫폼 등 대부분의 대규모 서비스에서 알림은 핵심 기능이다. 새로운 댓글, 친구 요청, 메시지 도착, 주문 상태 변경 등 사용자가 놓치지 말아야 할 사건을 즉시 전달해야 한다.

책에서는 다음 요구 사항을 정리한다.
* 알림은 실시간으로 사용자에게 도달해야 한다.
* 모바일(iOS, Android), 웹 등 다양한 플랫폼을 지원해야 한다.
* 알림 상태(읽음/안 읽음)를 관리해야 한다.
* 대규모 사용자 환경에서도 확장 가능해야 한다.
* 중복된 알림을 방지하고, 사용자에게 과도한 알림을 주지 않아야 한다.


### 2. 초기 설계 아이디어

가장 단순한 방법은 **알림을 데이터베이스에 저장하고, 클라이언트가 서버에 주기적으로 새로운 알림이 있는지 요청하는 방식**이다.

이 경우 동작 원리는 단순하다.
1. 이벤트(댓글 작성 등)가 발생하면 Notification 테이블에 기록한다.
2. 사용자는 일정 주기로 서버에 새로운 알림이 있는지 질의한다.
3. 서버는 해당 사용자의 알림을 찾아 내려준다.
⠀
이 방식은 구현은 쉽지만, 대규모 환경에서는 문제가 발생한다.


### 3. 문제점

* **지연 발생**: 사용자가 즉각적으로 알림을 받지 못한다.
* **낭비**: 대부분의 요청은 “새 알림 없음”을 반환하기 때문에 불필요한 트래픽이 많다.
* **확장성 부족**: 수억 명 사용자가 동시에 요청하면 데이터베이스와 서버 부하가 급증한다.
* **중복 알림**: 같은 이벤트로 인해 알림이 여러 번 발생할 수 있다.
* **여러 기기 동기화 미흡**: 한 기기에서 알림을 읽어도 다른 기기에는 반영되지 않는다.


### 4. 개선 방향

1. **실시간 전달 구조 도입**
모바일 단말에는 iOS의 APNs, Android의 FCM 같은 푸시 알림 서비스를 활용한다.
웹 브라우저에는 서버가 직접 알림을 전송하는 방식을 적용한다.

2. **비동기 이벤트 처리**
이벤트 발생과 알림 전달을 직접 연결하지 않고, 메시지 큐를 두어 비동기적으로 처리한다.
이렇게 하면 생산자와 소비자의 속도를 분리할 수 있어 시스템 안정성이 높아진다.

3. **알림 생성 서비스(Notification Service)**
큐에서 이벤트를 받아 사용자별 알림을 생성하고 저장한다.
알림의 집계, 중복 제거, 우선순위 적용 같은 로직을 담당한다.

4. **저장소 분리**
   * 단기 저장소(캐시): 최근 알림을 빠르게 읽기 위해 사용
   * 장기 저장소(DB): 영구적으로 알림을 보관
   
5. **알림 전달 서비스(Delivery Service)**
생성된 알림을 사용자 기기로 실제 전송한다.
모바일은 APNs/FCM 게이트웨이, 웹은 브라우저와의 연결을 활용한다.


### 5. 상세 설계
최종적으로 책에서 제시하는 설계는 다음과 같은 계층 구조를 가진다.
1. **이벤트 발생(Event Producer)**
   * 댓글, 좋아요, 친구 요청 등 사용자의 행동에서 발생
2. **메시지 큐(Queue)**
   * 이벤트를 일시적으로 저장해 소비자에게 전달
   * 알림 생성 로직과 분리해 확장성 확보
3. **알림 서비스(Notification Service)**
   * 큐에서 이벤트를 받아 알림 생성
   * 알림을 데이터베이스에 기록
   * 필요 시 집계와 필터링 적용
4. **알림 데이터베이스(Notification DB)**
   * 사용자 ID를 기준으로 알림 저장
   * 읽음/안읽음 상태 관리
5. **알림 전송 서비스(Delivery Service)**
   * APNs, FCM 같은 외부 푸시 서비스와 연동
   * 브라우저 연결(WebSocket 등)로 웹 사용자에게 알림 전달
6. **사용자 기기(User Device)**
   * 알림을 수신해 사용자에게 표시
   * 읽음 상태를 서버로 전달해 동기화
