# 단일 서버
* 사용자 요청 처리 흐름
  1. 도메인명(www.google.com) 접속
  2. DNS 조회 결과로 IP 주소(172.217.25.164) 반환
  3. 해당 IP 주소로 HTTP 요청 전달
  4. 요청을 받은 웹 서버가 HTML 페이지 및 JSON 형태의 응답 반환

---
 
# 데이터베이스
사용자가 늘면 서버 하나로는 충분하지 않아서 여러 서버를 두어야 한다.   
하나는 웹/모바일 트래픽 처리 용도이고, 다른 하나는 데이터베이스용으로 분리하면 그 각각을 독립적으로 확장해 나갈 수 있게 된다.

* 데이터베이스 종류
  * RDBMS
  * NoSQL

---

# 수직적 규모 확장 vs 수평적 규모 확장
* Scale Up
  * 수직적 규모 확장
  * 서버에 고사양 자원(CPU, RAM 등)을 추가
* Scale Out
  * 수평적 규모 확장
  * 더 많은 서버를 추가하여 성능을 개선

## Scale Up
서버로 유입되는 트래픽의 양이 적을 때는 단순하므로 좋은 선택이다.

하지만, 한 대의 서버에 CPU나 메모리를 무한대로 증설할 방법이 없으므로 한계가 있다.   
또한, 장애에 대한 자동복구(failover) 방안이나 다중화(redundancy) 방안을 제시하지 않기 때문에 서버에 장애가 발생하면 웹사이트/앱은 완전히 중단된다.

위와 같은 단점 때문에 대규모 애플리케이션을 지원하는 데는 Scale Out이 보다 적절하다.

## Scale Out
웹 서버가 다운되거나 너무 많은 사용자가 접속하게 되면 응답 속도가 느려지거나 서버 접속이 불가능해질 수도 있다.   
이런 문제를 해결하는 데는 부하 분산기 또는 로드 밸런서를 도입하는 것이 최선이다.

### 로드밸런서
로드밸런서는 부하 분산 집합(load balancing set)에 속한 웹 서버들에게 트래픽 부하를 고르게 분산하는 역할을 한다.

![로드밸런서](https://drive.google.com/thumbnail?id=1sDRWU3iUW_NsG2AH3BaedI1hf1d9PDcS&sz=w400)

사용자는 로드밸런서의 공개 IP 주소로 접속하므로, 웹 서버는 클라이언트의 접속을 직접 처리하지 않고,   
더 나은 보안을 위해 서버 간 통신에는 사설 IP 주소가 이용된다.
> 사설 IP 주소는 같은 네트워크에 속한 서버 사이의 통신에만 쓰일 수 있는 IP 주소로, 인터넷을 통해서는 접속할 수 없다.

<br>

부하 분산 집합에 또 하나의 웹 서버를 추가하고 나면 장애를 자동복구하지 못하는 문제(no failover)는 해소되며, 웹 계층의 가용성(availability)는 향상된다.
1. 서버 1이 다운되면 모든 트래픽은 서버 2로 전송되어 웹 사이트 전체가 다운되는 일이 방지된다.
2. 웹 사이트로 유입되는 트래픽이 증가하면 웹 서버 계층에 더 많은 서버를 추가하여 로드밸런서로 트래픽을 분산한다.

웹 계층을 보았으니 이제 데이터 계층을 보자.

### 데이터베이스 다중화
![DB 다중화](https://drive.google.com/thumbnail?id=1xfXtaGBfXULhX2ioMGy14vF_Ps7X0xZA&sz=w400)

데이터베이스를 다중화하면 아래와 같은 이점이 있다.
* 더 나은 성능
  
  master-slave 다중화 모델에서 모든 데이터 변경 연산은 master DB 서버로만 전달되는 반면 읽기 연산은 slave DB 서버들로 분산된다.   
  병렬로 처리될 수 있는 query의 수가 늘어나므로, 성능이 좋아진다.

* 안정성(reliability)

  DB 서버 가운데 일부가 파괴되어도 데이터를 지역적으로 떨어진 여러 장소에 다중화시켜 놓았기 때문에 데이터는 보존될 것이다.

* 가용성(availability)

  데이터를 여러 지역에 복제해 둠으로써, 하나의 DB 서버에 장애가 발생하더라도 다른 서버에 있는 데이터를 가져와 계속 서비스할 수 있게 된다.

### 로드밸런서 + 데이터베이스 다중화
로드밸런서와 데이터베이스 다중화를 고려하여 설계하면 아래와 같이 동작한다.

![로드밸런서와 DB 다중화 아키텍처](https://drive.google.com/thumbnail?id=1MhPI2HE07wIWvLirX_ft7Ovifj4AXFPM&sz=w400)

1. 사용자는 DNS로부터 로드밸런서의 public IP 주소를 받는다.
2. 사용자는 해당 IP 주소를 사용해 로드밸런서에 접속한다.
3. HTTP 요청은 서버A나 서버B로 전달된다.
4. 웹 서버는 사용자의 데이터를 slave DB 서버에서 읽는다.
5. 웹 서버는 데이터 변경 연산을 master DB로 전달한다.(insert, update, delete 연산 등이 해당)

웹 계층과 데이터 계층에 대해 알아봤다.   
이제 응답시간(latency)을 개선해 보자.   
latency는 cache를 붙이고 정적 콘텐츠를 콘텐츠 전송 네트워크(CDN)로 옮기면 개선할 수 있다.

---

# 캐시
캐시는 값비싼 연산 결과 또는 자주 참조되는 데이터를 메모리 안에 두고, 뒤 이은 요청이 보다 빨리 처리될 수 있도록 하는 저장소다.

애플리케이션의 성능은 DB를 얼마나 자주 호출하느냐에 크게 좌우되는데, 캐시는 그런 문제를 완화할 수 있다.

## 캐시 계층
캐시 계층(cache tier)은 데이터가 잠시 보관되는 곳으로 DB 보다 훨씬 빠르다.

별도의 cache tier를 두면 성능이 개선될 뿐 아니라 DB의 부하를 줄일 수 있고, cache tier의 규모를 독립적으로 확장시키는 것도 가능해진다.

아래는 캐시 서버를 두는 방법 중 하나다.

![Cache](https://drive.google.com/thumbnail?id=1Y4Ij6e8WifgEkbxWmViT97ndOeW8J-qQ&sz=w500)

1. 만일 데이터가 캐시에 있으면 캐시에서 데이터를 읽음 (cache hit)
2. 데이터가 캐시에 없으면 DB에서 해당 데이터를 읽어 캐시에 씀 (cache miss)
3. 웹 서버에 데이터 반환

이러한 캐시 전략을 캐시 우선 읽기 전량(read-through caching strategy)라고 부른다. (이외에도 여러 캐시 전략들이 있다.)

## 캐시 사용 시 유의할 점
캐시 서버 또한 SPOF(단일 장애 지점)을 피하려면 여러 지역에 걸쳐 캐시 서버를 분산시켜야 한다.

---

# 콘텐츠 전송 네트워크(CDN)
CDN은 정적 콘텐츠를 전송하는 데 쓰이는, 지리적으로 분산된 서버의 네트워크로,   
이미지, 비디오, css, js 파일 등을 캐시할 수 있다.

CDN이 어떻게 동작하는지 알아보자.

![CDN 동작 원리](https://drive.google.com/thumbnail?id=1Sqr_ncwDS4ukpJhVxbgnt8cXwx5FfqcI&sz=w500)

1. image.png 액세스 (사용자A)
2. 이미지가 CDN에 없으면 원본 서버에서 가져옴
3. 가져온 이미지를 CDN에 저장
4. image.png 반환 (사용자A)
5. image.png 액세스 (사용자B)
6. image.png 반환 (사용자B)

캐시와 CDN을 추가하여 설계해 보자.

![CDN 및 캐시 추가 아키텍처](https://drive.google.com/thumbnail?id=1dd5mkcqZ53GjoH26cT0x2iJuSK_Uxr7V&sz=w400)

1. 정적 콘텐츠는 더 이상 웹 서버를 통해 서비스하지 않으며, CDN을 통해 제공하여 더 나은 성능을 보장한다.
2. 캐시가 DB 부하를 줄여준다.

---

# 무상태(stateless) 웹 계층
이제 웹 계층을 수평적으로 확장하는 방법을 고민해 보자.   
이를 위해서는 상태 정보(사용자 세션 데이터와 같은)를 웹 계층에서 제거해야 한다.

바람직한 전략은 상태 정보를 RDB나 NoSQL 같은 지속성 저장소에 보관하고, 필요할 때 가져오도록 하는 것이다.   
이 같은 웹 계층을 무상태 웹 계층이라 부른다.

## 상태 정보 의존적인 아키텍처
상태 정보를 보관하는 서버는 클라이언트 정보, 즉 상태를 유지하여 요청들 사이에 공유되도록 한다.   
무상태 서버에는 이런 장치가 없다.

상태 정보 의존적인 아키텍처의 문제는 같은 클라이언트로부터의 요청은 항상 같은 서버로 전송되어야 한다는 것이다.

## 무상태 아키텍처
무상태 아키텍처는 클라이언트로부터의 HTTP 요청은 어떤 웹 서버로도 전달될 수 있다.

웹 서버는 상태 정보가 필요할 경우 공유 저장소로부터 데이터를 가져온다.   
따라서 상태 정보는 웹 서버로부터 물리적으로 분리되어 있다.   
이런 아키텍처는 단순하고, 안정적이며, 규모 확장이 쉽다.

무상태 아키텍처에서 세션 데이터를 웹 계층에서 분리하고 지속성 데이터 보관소에 저장하도록 만든다.   
이 공유 저장소는 RDB, Cache, NoSQL 일 수 있다.

> autoscaling: 트래픽 양에 따라 웹 서버를 자동으로 추가하거나 삭제하는 기능

---

# 데이터 센터
가용성을 높이고 전 세계 어디서도 쾌적하게 사용할 수 있도록 하기 위해서는 여러 데이터 센터를 지원하는 것이 필수다.

시스템을 더 큰 규모로 확장하기 위해서는 시스템의 컴포넌트를 분리하여, 각기 독립적으로 확장될 수 있도록 해야 한다.   
**메시지 큐**는 많은 실제 분산 시스템이 이 문제를 풀기 위해 채용하고 있는 핵심적 전략 가운데 하나다.

---

# 메시지 큐
메시지 큐는 메시지의 무손실(durability, 즉 메시지 큐에 일단 보관된 메시지는 소비자가 꺼낼 때까지 안전히 보관된다는 특성)을 보장하는, 비동기 통신을 지원하는 컴포넌트로, 메시지의 버퍼 역할을 하며, 비동기적으로 전송한다.

![Message queue](https://drive.google.com/thumbnail?id=1tAUdl9g0ciDfF9CXjgdIhx94_8GZdaRN&sz=w500)

메시지 큐를 이용하면 서비스 또는 서버 간 결합이 느슨해져서, 규모 확장성이 보장되어야 하는 안정적 애플리케이션을 구성하기 좋다.

생산자는 소비자 프로세스가 다운되어 있는 메시지를 발행할 수 있고, 소비자는 생산자 서비스가 가용한 상태가 아니더라도 메시지를 수신할 수 있다.

---

# 로그, 메트릭 그리고 자동화
* 로그

  에러 로그 모니터링

* 메트릭

  시스템의 현재 상태 파악(CPU, 메모리, DB성능, DAU 등)

* 자동화

  CI/CD 도구를 활용하여 문제를 쉽게 감지하거나, 개발 생산성을 크게 향상

이러한 도구들과 메시지 큐를 적용하여 아키텍처를 수정해 보자.

![Message queue 및 도구 추가 아키텍처](https://drive.google.com/thumbnail?id=1bxyaoG9Exqe4N7xj3p8FZrlVtnQIbqrC&sz=w400)

1. 메시지 큐는 각 컴포넌트가 보다 느슨히 결합(loosely copled)될 수 있도록 하고, 결함에 대한 내성을 높인다.
2. 로그, 모니터링, 메트릭, 자동화 등을 지원하기 위한 장치를 추가한다.

---

# 데이터베이스의 규모 확장

## Scale up
수직적 규모 확장법은 기존 서버에 더 많은, 또는 고성능의 자원(CPU, RAM, 디스크 등)을 증설하는 방법이다.

이 방법에는 아래와 같은 심각한 약점이 있다.
* DB 서버 하드웨어에는 한계가 있으므로 CPU, RAM 등을 무한 증설할 수는 없다.
* SPOF(Single Point of Failure)로 인한 위험성이 크다.
* 비용이 많이 든다.

## Sharding
수평적 확장은 더 많은 서버를 추가함으로써 성능을 향상시킬 수 있도록 한다.

샤딩은 대규모 DB를 샤드(shard)라고 부르는 작은 단위로 분할하는 기술을 일컫는다.   
모든 샤드는 같은 스키마를 쓰지만 샤드에 보관되는 데이터 사이에는 중복이 없다.

샤드로 분할된 DB를 보자.

![샤드로 분리된 DB](https://drive.google.com/thumbnail?id=1hf1c1ta1GGwRn8Fxj7cAivniEdzT8qRm&sz=w300)

이 사례에서는 `user_id % 4`를 해시 함수로 사용하여 데이터가 보관되는 샤드를 정한다.

> 샤딩 전략을 구현할 때 고려해야 할 가장 중요한 것은 sharding key를 어떻게 정하느냐 하는 것이다.
> 샤딩 키는 partition key라고도 부르는데, 데이터가 어떻게 분산될지 정하는 하나 이상의 칼럼으로 구성된다.

<br>

샤딩 키를 통해 올바른 DB에 질의를 보내어 데이터 조회나 변경을 처리하므로 효율을 높일 수 있다.   
하지만 샤딩을 도입하면 시스템이 복잡해지고 아래와 같이 풀어야 할 새로운 문제도 생긴다.

* 데이터의 재 샤딩(resharding)

  샤드 소진이라고도 부르는 현상이 발생하면 샤드 키를 계산하는 함수를 변경하고 데이터를 재배치해야 한다.

* 유명인사(celebrity) 문제

  hotspot key 문제라고도 부르는데, 특정 샤드에 질의가 집중되어 서버에 과부하가 걸리는 문제다.

* 조인과 비정규화(join and de-normalization)

  일단 하나의 DB를 여러 샤드 서버로 쪼개고 나면, 여러 샤드에 걸친 데이터를 조인하기 힘들어져 비정규화로 해결하기도 한다.

---

# 백만 사용자, 그리고 그 이상
시스템의 규모를 확장하는 것은 지속적이고 반복적인 과정이며,
사용자가 많아질수록 시스템을 최적화하고 더 작은 단위의 서비스로 분할해야 할 수도 있다.

시스템 규모 확장을 위해 살펴본 기법들을 다시 한번 정리해 보자.
* 웹 계층은 무상태 계층으로
* 모든 계층에 다중화 도입
* 가능한 한 많은 데이터를 캐시할 것
* 여러 데이터 센터를 지원할 것
* 정적 콘텐츠는 CDN을 통해 서비스할 것
* 데이터 계층은 샤딩을 통해 그 규모를 확장할 것
* 각 계층은 독립적 서비스로 분할할 것
* 시스템을 지속적으로 모니터링하고, 자동화 도구들을 활용할 것

