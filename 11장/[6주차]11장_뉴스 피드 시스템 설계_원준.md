# 📝 1단계. 문제 이해 및 설계 범위 확정
```
질문
* 모바일? 웹?
* 중요 기능은?
* 뉴스 피드에서의 스토리 순서 기준은?
    * 최신? topic score?
    * 가까운 친구?
* 한 명의 유저가 가질 수 있는 최대 친구 수는?
* 트래픽 규모는?
* 피드에 이미지나 비디오 스토리도 올라올 수 있는지?
```

# 🧐 2단계. 개략적 설계안 제시 및 동의 구하기

두 가지 설계안을 살펴 보자.
1. **피드 발행 (Feed Publishing)**
   ```
   * 사용자가 스토리를 포스팅하면 해당 데이터를 캐시와 데이터베이스에 기록한다.
   * 새 포스팅은 친구의 뉴스 피드에도 전송된다.
   ```
2. **뉴스 피드 생성 (News Feed Building)**
   ```
   * 지면 관계상 뉴스 피드는 모든 친구의 포스팅을 시간 흐름 역순으로 모아서 만든다고 가정한다.
   ```

## 📡 뉴스 피드 API
* 상태 정보 업데이트
* 뉴스 피드 조회
* 친구 추가
* ...

## 📤 1. 개략적 설계안: 피드 발행
![피드 발행](https://drive.google.com/thumbnail?id=1zMbU56Nj9UW6nePopKQANKzNimV5R6No&sz=w400)
* **포스팅 저장 서비스 (Post Service)**
  * 새 포스팅을 데이터베이스와 캐시에 저장
* **포스팅 전송 서비스 (Fanout Service)**
  * 새 포스팅을 친구의 뉴스 피드에 push
  * 뉴스 피드 데이터는 캐시에 보관하여 빠른 조회
* **알림 서비스 (Notification Service)**
  * 친구들에게 새 포스팅이 올라왔음을 알리거나, 푸시 알림을 보내는 역할을 담당


## 📥 2. 개략적 설계안: 피드 생성
![피드 생성](https://drive.google.com/thumbnail?id=1i8l9_0DETJPh47fvr6NP0zWdompDBll2&sz=w300)
* **뉴스 피드 서비스 (News Feed Service)**
  * 캐시에서 뉴스 피드를 가져오는 서비스
* **뉴스 피드 캐시 (New Feed Cache)**
  * 뉴스 피드를 렌더링할 때 필요한 피드 ID를 보관

# 🛠️ 3단계. 상세 설계
뉴스 피드 발행과 생성 부분의 설계를 보다 상세히 살펴보자.

## 📤 피드 발행 흐름 상세 설계
![피드 발행 흐름 상세 설계](https://drive.google.com/thumbnail?id=1Y3iKQZq5UxAyaB1fUVRmrQ4bYyRoQ59-&sz=w600)
* **웹서버**
  * 인증, 처리율 제한
  * 스팸을 막고, 유해한 컨텐츠가 자주 올라오는 것을 방지하기 위해서 **특정 기간 동안 한 사용자가 올릴 수 있는 포스팅의 수에 제한**을 두어야 한다.
* **포스팅 전송(팬아웃) 서비스**
  * fanout은 어떤 사용자의 새 포스팅을 그 사용자와 친구 관계에 있는 모든 사용자에게 전달하는 과정
  * 모델 종류
    1. **쓰기 시점 (Push Model)**: fanout-on-write하는 모델
    2. **읽기 시점 (Pull Model)**: fanout-on-read하는 모델

### 🔥 쓰기 시점에 팬아웃하는 모델 (Push Model)
새로운 포스팅을 기록하는 시점에 뉴스 피드를 갱신하게 된다.
즉, 포스팅이 완료되면 바로 해당 사용자의 캐시에 해당 포스팅을 기록한다.
* **장점**
  * 뉴스 피드 실시간 갱신 -> 친구 목록에 있는 사용자에게 즉시 전송
  * 새 포스팅이 기록되는 순간 - 뉴스 피드가 이미 갱신됨(pre-computed) -> 뉴스 피드를 읽는 데 드는 시간 단축
* **단점**
  * **핫키(hotkey) 이슈**
    * 친구가 많은 사용자의 경우 -> 친구 목록을 가져오고 그 목록에 있는 사용자 모두의 뉴스 피드를 갱신 -> 많은 시간 소요
  * 서비스를 자주 이용하지 않는 사용자의 피드까지 갱신 -> 컴퓨팅 자원 낭비

### 💧 읽기 시점에 팬아웃하는 모델 (Pull Model)
피드를 읽어야 하는 시점에 뉴스 피드를  갱신한다. 따라서 요청 기반(on-demand) 모델이다.
즉, 사용자가 본인 홈페이지나 타임 라인을 **로딩하는 시점에 새로운 포스트를 조회**하게 된다.

* **장점**
  * 휴먼계정 또는 로그인을 거의 하지 않는 사용자의 경우 -> 로그인하기까지는 어떤 컴퓨팅 자원도 소모X
  * 데이터를 친구 각각에 푸시하는 작업X -> 핫키 이슈X
* **단점**
  * 뉴스 피드를 읽는 데 많은 시간 소요

> **Hybrid Approach!**
> 쓰기 시점에 팬아웃하는 push모델과 읽기 시점에 팬아웃하는 pull모델을 결합하여 장점은 취하고, 단점은 버리는 전략을 설계해보자.
>
> * **뉴스 피드 빠른 조회**
>   * **Push 모델**: 대부분의 사용자
>   * **Pull 모델**: 친구나 follower가 아주 많은 경우 (e.g., 셀럽) -> 시스템 과부하 방지
> * **핫키 이슈 완화**
>   * 안정 해시를 통해 요청과 데이터를 보다 고르게 분산

![팬아웃 서비스 전략](https://drive.google.com/thumbnail?id=1RpIc_w_N0QmeuKUWV670Oa93LS_JmUjI&sz=w400)
1. 친구 관계나 친구 추천을 관리하기 적합한 **그래프 데이터베이스** 사용
2. 사용자 정보 캐시에서 친구들의 정보 조회 -> 데이터베이스에서 스토리 차단 친구 정보 조회 -> 사용자의 새 스토리는 일부 친구들에게만 공유
3. 친구 목록과 새 스토리의 포스팅 ID를 **메시지 큐**에 발행
4. 팬아웃 작업 서버가 메시지 큐에서 데이터를 소비하여 뉴스 피드 데이터를 캐시에 저장
   * 뉴스피드 캐시는 `<포스팅 ID, 사용자 ID>`의 순서쌍을 보관하는 매핑 테이블
   * 메모리 크기를 적정 수준으로 유지하기 위해 캐시 크기를 제한(해당 값 조정 가능)
   * **Cache Miss?**
     * 어떤 사용자가 뉴스 피드에 올라온 수천 개의 스토리를 전부 훑어보는 일이 벌어질 확률은 매우 낮고, 대부분의 사용자는 최신 스토리를 조회
     * 발생 확률 낮음

## 📥 피드 읽기 흐름 상세 설계
![피드 읽기 흐름 상세 설계](https://drive.google.com/thumbnail?id=1RFOQnWmtvWuCWMQI-7G0CzZHx7Ekk1nz&sz=w600)
1. 사용자가 뉴스 피드 조회 요청
2. 로드밸런서가 요청을 웹 서버 가운데 하나로 전송
3. 웹 서버는 피드를 가져오기 위해 뉴스 피드 서비스를 호출
4. 뉴스 피드 서비스는 뉴스 피드 캐시에서 포스팅 ID 목록을 조회
5. 뉴스 피드에 표시할 사용자 이름, 사진, 포스팅 콘텐츠, 이미지 등을 **사용자 정보 캐시와 포스팅 캐시에서 가져와 완전한 뉴스 피드를 생성**
6. 생성된 뉴스 피드를 JSON 형태로 클라이언트에게 보내, 클라이언트는 해당 피드를 렌더링

## 🗄️ 캐시 구조
캐시는 뉴스 피드 시스템의 핵심 컴포넌트로, 본 설계안의 경우 캐시를 다섯 계층으로 나눈다.

| 계층 | 내용 |
| :--- | :--- |
| **뉴스 피드** | 뉴스 피드 ID 보관 |
| **콘텐츠** | 포스팅 데이터 (인기 콘텐츠는 별도 관리) |
| **소셜 그래프** | 사용자 간 관계 정보 (팔로워, 팔로잉) |
| **행동** | 포스팅에 대한 사용자 반응 (좋아요, 댓글 등) |
| **횟수** | 좋아요, 댓글, 팔로워 수 등 |

* **뉴스 피드**: 뉴스 피드 ID 보관
* **콘텐츠**: 포스팅 데이터 보관 (인기 콘텐츠는 따로 보관)
* **소셜 그래프**: 사용자 간 관계 정보 보관
* **행동(action)**: 포스팅에 대한 사용자의 행위에 관한 정보 보관
* **횟수(counter)**: 팔로어, 팔로잉 횟수 정보도 보관

# 🏁 4단계. 마무리
뉴스 피드 발행과 생성 두 부분에 대한 설계안을 살펴보았다.

아래는 추가적으로 논의할 만한 주제들이다.
* **데이터베이스 규모 확장**: 수직적 vs 수평적, SQL vs NoSQL, 다중화, 샤딩 등
* **웹 계층 무상태(stateless) 운영**
* **캐시 전략**: 가능한 한 많은 데이터를 캐시할 방법
* **다중 데이터 센터 지원**
* **메시지 큐**: 컴포넌트 간 결합도 낮추기
* **핵심 메트릭 모니터링**: QPS, 지연시간 등

---

# 🌐 실제 적용 사례
* **Facebook**: 사용자의 뉴스피드는 친구들의 활동, '좋아요'를 누른 페이지, 가입한 그룹의 게시물 등 다양한 요소를 복잡한 랭킹 알고리즘을 통해 조합하여 보여줍니다. 초기에는 Pull 모델에 가까웠지만, 현재는 Push와 Pull을 혼합한 하이브리드 모델을 사용합니다.
* **Twitter**: 트위터는 '팬아웃' 개념을 적극적으로 사용하는 대표적인 서비스입니다. 사용자가 트윗을 하면, 해당 트윗은 팔로워들의 타임라인에 Push됩니다. 하지만 팔로워가 매우 많은 셀럽의 경우, 모든 팔로워에게 즉시 Push하는 대신 일부는 Pull 방식으로 처리하여 부하를 조절합니다.
* **Instagram**: 페이스북과 유사하게, 이미지와 비디오 중심의 피드를 제공합니다. 친구의 게시물뿐만 아니라 사용자의 관심사를 분석하여 추천 게시물을 함께 보여주는 랭킹 알고리즘이 핵심적인 역할을 합니다.

# 💬 토론 주제
1.  **랭킹 알고리즘**: 단순히 시간순으로 피드를 보여주는 것과 사용자의 관심도, 친구와의 관계 등을 고려한 랭킹 알고리즘을 적용하는 것의 장단점은 무엇일까요? 랭킹 알고리즘을 도입한다면 어떤 요소들을 고려해야 할까요? (e.g., 클릭률, 머문 시간, 좋아요, 댓글, 공유 등)
2.  **실시간 업데이트의 중요성**: 모든 사용자에게 피드가 실시간으로 업데이트되는 것이 항상 중요할까요? 실시간 성을 어느 정도 포기하더라도 시스템의 안정성과 비용 효율성을 높이는 방향의 설계(e.g., 주기적인 업데이트, Pull 모델 확대)에 대해 어떻게 생각하시나요?
3.  **광고 피드 통합**: 뉴스 피드 중간에 광고를 자연스럽게 노출시키려면 기존 시스템 설계를 어떻게 변경해야 할까요? 광고 서버와의 연동, 타겟팅 광고를 위한 사용자 데이터 활용, 광고 노출 횟수 제한 등의 기술적 과제를 논의해 보세요.
4.  **'핫 콘텐츠' 감지**: 특정 게시물이 짧은 시간 안에 바이럴(viral)하게 퍼져나가는 '핫 콘텐츠'를 어떻게 감지하고, 더 많은 사용자에게 노출시킬 수 있을까요? 실시간 스트림 처리 기술(e.g., Kafka Streams, Spark Streaming)을 활용하는 방안에 대해 이야기해 보세요.

# 🔑 면접 핵심 내용 (질문과 답안)

**Q1: 뉴스 피드 시스템 설계 시 가장 먼저 고려해야 할 점은 무엇인가요? Push 모델과 Pull 모델 중 어떤 것을 선택하시겠습니까?**

<details>
<summary>답안</summary>

**A1:** 가장 먼저 읽기 연산(피드 조회)과 쓰기 연산(포스트 게시)의 비율(Read/Write Ratio)을 고려해야 합니다. 일반적으로 뉴스 피드 시스템은 쓰기보다 읽기가 훨씬 빈번하게 일어납니다. 따라서 읽기 성능에 최적화된 설계를 하는 것이 중요합니다.

Push 모델과 Pull 모델 선택은 정답이 정해져 있지 않으며, 시스템의 요구사항과 트레이드오프를 고려하여 결정해야 합니다.
*   **Push (Fan-out on Write)**: 쓰기 시점에 팔로워들의 피드를 미리 생성해두는 방식입니다. 읽기 속도가 매우 빠르다는 장점이 있지만, 팔로워가 많은 유저(셀럽)의 경우 쓰기 작업 시 엄청난 부하(핫키 문제)를 유발할 수 있습니다.
*   **Pull (Fan-out on Read)**: 읽기 시점에 팔로워하는 사람들의 포스트를 가져와 피드를 생성하는 방식입니다. 쓰기 부하가 적고, 비활성 유저에게 불필요한 리소스를 낭비하지 않는 장점이 있습니다. 하지만 읽기 시점의 지연 시간이 길어질 수 있습니다.

**최적의 접근 방식은 이 둘을 결합한 하이브리드 모델입니다.** 대부분의 일반 유저에게는 Push 모델을 적용하여 빠른 읽기 속도를 제공하고, 팔로워가 매우 많은 셀럽에게는 Pull 모델을 적용하거나, 혹은 셀럽의 포스트를 조회하는 요청에 대해서만 Pull 방식을 사용해 핫키 문제를 해결하고 시스템 전반의 부하를 분산시킬 수 있습니다.

</details>

**Q2: 수백만 명의 팔로워를 가진 사용자가 포스트를 올렸을 때 발생하는 '팬아웃' 문제를 어떻게 해결할 수 있나요?**

<details>
<summary>답안</summary>

**A2:** 이는 '핫키' 또는 'Thundering Herd' 문제라고도 불리며, 몇 가지 방법으로 해결할 수 있습니다.
1.  **하이브리드 접근**: 앞서 언급했듯이, 셀럽과 같은 특정 유저에게는 Pull 모델을 적용합니다. 즉, 사용자들이 피드를 요청할 때 셀럽의 포스트를 직접 가져와서 조합하도록 하는 것입니다.
2.  **팬아웃 서비스 분리 및 큐(Queue) 사용**: 팬아웃 로직을 별도의 서비스로 분리하고, 포스트가 생성되면 메시지 큐(e.g., RabbitMQ, Kafka)에 작업을 넣습니다. 여러 워커(Worker)들이 큐에서 작업을 가져와 병렬로 처리함으로써 팬아웃 작업을 비동기적으로 수행하고 부하를 분산시킬 수 있습니다. 이를 통해 특정 유저의 포스팅이 전체 시스템에 미치는 영향을 최소화할 수 있습니다.
3.  **계층화된 팬아웃**: 1차, 2차 등 친구 관계의 깊이에 따라 팬아웃의 범위를 조절하거나, 활성 사용자에게 우선적으로 전달하는 등 팬아웃 프로세스를 계층적으로 설계하여 부하를 조절할 수 있습니다.
4.  **사용자 샤딩(Sharding)**: 사용자를 여러 샤드(shard)로 분산시키고, 팬아웃 작업 또한 각 샤드별로 독립적으로 수행되도록 하여 단일 지점의 부하를 막을 수 있습니다.

</details>

**Q3: 뉴스 피드의 데이터는 어떻게 저장하고 캐싱하는 것이 효율적일까요?**

<details>
<summary>답안</summary>

**A3:** 뉴스 피드 데이터는 크게 '피드 자체'와 '콘텐츠 데이터'로 나눌 수 있습니다.
*   **피드 데이터 (Feed Data)**: 각 사용자의 뉴스 피드는 포스트 ID의 목록으로 볼 수 있습니다. 이 목록은 사용자가 피드를 조회할 때마다 동적으로 생성되거나 (Pull), 미리 생성되어 (Push) 저장됩니다. 이 데이터는 매우 자주 읽히므로 **Redis와 같은 인메모리 캐시**에 `<UserId, List<PostId>>` 형태로 저장하는 것이 매우 효율적입니다. 캐시에는 최신 N개의 포스트 ID만 저장하여 메모리 사용량을 관리하고, 그 이전의 데이터는 데이터베이스에서 읽어오도록 할 수 있습니다.
*   **콘텐츠 데이터 (Content Data)**: 포스트의 실제 내용(텍스트, 이미지 URL, 작성자 정보 등)은 `<PostId, PostData>` 형태로 저장합니다. 이 역시 자주 접근되므로 **Memcached나 Redis 같은 캐시**에 저장합니다. 이미지나 비디오와 같은 대용량 미디어 파일은 S3나 CDN과 같은 별도의 오브젝트 스토리지/CDN을 사용하는 것이 좋습니다.
*   **데이터베이스**: 최종적으로 모든 데이터는 영구 저장을 위해 데이터베이스에 보관되어야 합니다. 대규모 쓰기 및 읽기 트래픽을 감당하기 위해 NoSQL(e.g., Cassandra, DynamoDB)을 사용하거나, 관계형 데이터베이스를 샤딩(Sharding)하여 수평적으로 확장하는 전략을 사용할 수 있습니다. 소셜 관계 데이터(친구, 팔로워)는 그래프 데이터베이스(e.g., Neo4j)에 저장하면 관계 기반 조회에 더 효율적일 수 있습니다.

</details>
